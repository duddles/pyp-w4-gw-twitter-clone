import sqlite3
import jinja2
import os
from hashlib import md5
from functools import wraps
from flask import Flask
from flask import (g, request, session, redirect, render_template,
                   flash, url_for, send_from_directory)

app = Flask(__name__)

def connect_db(db_name):
    return sqlite3.connect(db_name)

@app.before_request
def before_request():
    g.db = connect_db(app.config['DATABASE'][1])

def login_required(f): # decorator to make sure someone is logged in
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'username' not in session: # session['username']
            return redirect(url_for('login', next=request.url))
        return f(*args, **kwargs)
    return decorated_function
    
# Login page
@app.route('/login', methods=['GET', 'POST'])
def login():
    # if already logged in send them to user feed page by way of the '/'
    # doing this to follow what the test has
    if 'username' in session:
          return redirect(url_for('index'))
          
    if request.method == 'POST': # they entered username and password
        username = request.form['username']
        password = request.form['password']
        password = password.encode('utf-8') # needs to be in bytes
        password = md5(password).hexdigest() # http://pythoncentral.io/hashing-strings-with-python/
        
        # check the db for matching username/password
        users = g.db.execute('SELECT id, username, password FROM user')
        for user in users:
            if username == user[1] and password == user[2]:
                # set the session variables
                session['username'] = username
                session['user_id'] = user[0]
                #return redirect('/')
                return redirect(url_for('index'))
        
        flash('Invalid username or password') 
    return render_template('login.html')
    
# Profile page
@app.route('/profile', methods = ['GET','POST'])
@login_required
def profile():
    if request.method == 'POST':
        try: # update the user profile
            new_username = request.form['username']
            new_firstname = request.form['first_name']
            new_lastname = request.form['last_name']
            new_birthdate = request.form['birth_date']
            sql_command = 'UPDATE user SET username = ?, first_name = ?, \
            last_name = ?, birth_date = ? WHERE id = ?'
            sql_args = [new_username, new_firstname, new_lastname, 
            new_birthdate, session['user_id']]
            g.db.execute(sql_command, sql_args)
            g.db.commit()
            
            flash('Your profile was correctly updated')
        except:
            flash('Your profile was not updated')
        
    # use jinja to display the profile page
    sql_command = 'SELECT first_name, last_name, birth_date FROM user WHERE id = ?;'
    cursor = g.db.execute(sql_command, [session['user_id']])
    first_name, last_name, birth_date = cursor.fetchone()
    return render_template('dynamic_profile.html', username = session['username'],
    firstname = first_name, lastname = last_name, birthdate = birth_date, urlroot = request.url_root)

# Twitter feed page
@app.route('/<username>', methods=['GET', 'POST'])
def twitter_feed(username):
  
    if request.method == 'POST': # submitting a tweet
        if 'username' not in session: # for test conditions
            return redirect(url_for('index')), 403
            
        tweet = request.form.get('tweet') # 'tweet' comes from the html field name
        
        # tweet.id and tweet.created will be auto-generated by sqlite3
        sql_command = "INSERT INTO tweet ('user_id', 'content') VALUES (?, ?)"
        g.db.execute(sql_command, (session['user_id'], tweet))
        g.db.commit()
        flash('Tweet was added')
    
    # We want all the tweets from this username
    all_tweets = get_all_user_tweets(username)

    if 'username' in session and session['username'] == username:
        return render_template('dynamic_own_feed.html', tweets=all_tweets[::-1], username=session['username'])
    else: # we are either not logged in or logged in as a different user
        if 'username' in session:
            loggedin_username = session['username']
        else:
            loggedin_username = ''
        return render_template('dynamic_other_feed.html', tweets=all_tweets[::-1], 
        page_username=username, loggedin_username=loggedin_username)
    
# Helper function to get all the user tweets as a list of dicts
def get_all_user_tweets(user_name):
    template_data = []
    
    # From the user table get the user_id for that name
    user_id = g.db.execute('select id from user where username = ?',[user_name])
    user_id = next(user_id) # user_id is now (10,)
    user_id = user_id[0] # to get as an int
    
    # Now use the user_id to get all their tweets from tweet table
    sql_command = 'SELECT user_id, created, content, id FROM tweet WHERE user_id = ?'
    user_tweets = g.db.execute(sql_command,[user_id])
    for tweet in user_tweets:
        dict_keys = ("user_id", "created", "content", "tweet_id")
        row_dict = dict(zip(dict_keys, tweet))
        template_data.append(row_dict)

    return template_data

# Deleting tweets 
@app.route('/tweets/<int:tweet_id>/delete', methods=['POST'])
@login_required
def delete_tweet(tweet_id):
    # When click on delete the form action is:
    # form action="/tweets/{{tweet.tweet_id}}/delete?next={{urlroot}}{{username}}"
    sql_command = 'DELETE FROM tweet WHERE id = ?'
    g.db.execute(sql_command, [tweet_id])
    g.db.commit()
    flash('Tweet was deleted')
    return redirect(url_for('index'))

# Logout
@app.route('/logout')
@login_required
def logout():
   # remove the username from the session if it is there
   session.pop('username', None)
   session.pop('user_id', None)
   
   # but if they logout from another page do we want to return them to that page?
   return redirect(url_for('index'))

# Index site will either send to login or to that person's tweets   
@app.route('/', methods=['GET'])
@login_required
def index():
    if 'username' in session:
        return redirect('/{}'.format(session['username']))

# Remaining questions:
# what exactly is next, the info after ? in url ?next=login

# how would it work with multiple submit buttons on one page, how 
# does methods know which post is which?
